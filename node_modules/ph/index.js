// Generated by CoffeeScript 1.9.2

/* PH - a better git push */

(function() {
  var GitPush, _, args, argv, chalk, exec, exists, inquirer, pkg, ref, spawn,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  inquirer = require("inquirer");

  ref = require("child_process"), exec = ref.exec, spawn = ref.spawn;

  exists = require("fs").exists;

  chalk = require("chalk");

  pkg = require("./package.json");

  _ = require("underscore");

  args = process.argv.slice(2).join(' ');

  if (args[0] !== '-') {
    args = "-" + args;
  }

  args = args.split(" ");

  argv = require("minimist")(args);

  GitPush = (function() {
    function GitPush(argv1) {
      var action;
      this.argv = argv1;
      this.getBranch = bind(this.getBranch, this);
      this.getRemote = bind(this.getRemote, this);
      if (this.argv.help || this.argv['?']) {
        console.log(this.help());
        return;
      }
      if (this.argv.v || this.argv.version) {
        console.log("ph - version " + (chalk.cyan(pkg.version)) + "\nRun " + (chalk.blue("--help")) + " for help");
        return;
      }
      if (this.argv.pull || this.argv.l) {
        action = "pull";
      } else {
        action = "push";
      }
      this.getRemote((function(_this) {
        return function(remote1) {
          _this.remote = remote1;
          return _this.getBranch(function(branch1, pushToBranch) {
            var child, extra, ignoreFlags, onData;
            _this.branch = branch1;
            _this.pushToBranch = pushToBranch;
            ignoreFlags = ["_", "pull", "remote", "branch", "origin", "current-branch", "v", "q", "n", "o", "h", "p", "m", "d", "c", "l"];
            extra = Object.keys(_this.argv).map(function(k) {
              if (indexOf.call(ignoreFlags, k) < 0) {
                if (typeof _this.argv[k] === "boolean") {
                  if (k.length === 1) {
                    return "-" + k;
                  } else {
                    return "--" + k;
                  }
                } else {
                  return "--" + k + " " + _this.argv[k];
                }
              } else {
                return "";
              }
            });
            extra = extra.join(" ").trim(" ");
            if (_this.pushToBranch === _this.branch || !_this.pushToBranch) {
              _this.pushToBranch = "";
            } else {
              _this.pushToBranch = ":" + _this.pushToBranch;
            }
            console.log(["----->", "git", action, chalk.magenta(_this.remote), "" + (chalk.cyan(_this.branch)) + (chalk.bgBlue(_this.pushToBranch)), extra].join(" "));
            child = spawn("git", _.compact([action, _this.remote, _this.branch, _this.pushToBranch, extra]));
            onData = function(buffer) {
              var s;
              s = buffer.toString();
              if (s.indexOf("up-to-date") !== -1) {
                s = "-----> " + (chalk.green(s));
              }
              if (s.indexOf("fatal: ") !== -1) {
                s = "-----> " + (chalk.red(s));
              }
              return console.log(s.trim('\n'));
            };
            child.stdout.on('data', onData);
            return child.stderr.on('data', onData);
          });
        };
      })(this));
    }

    GitPush.prototype.getRemote = function(cb) {
      var remote;
      if (this.argv.o || this.argv.origin) {
        return cb("origin");
      }
      if (this.argv.h || this.argv.heroku) {
        return cb("heroku");
      }
      if (this.argv.p || this.argv.prod) {
        return cb("production");
      }
      if (this.argv.u || this.argv.upstream) {
        return cb("upstream");
      }
      if (!(this.argv.r || this.argv.remote)) {
        return exec("git remote", function(err, remotes) {
          var r;
          r = remotes.trim("\n").split("\n");
          return inquirer.prompt([
            {
              name: "remote",
              message: "---> remote?",
              "default": "origin",
              type: "list",
              choices: r
            }
          ], function(answers) {
            var remote;
            remote = answers.remote;
            return cb(remote);
          });
        });
      } else {
        remote = this.argv.r || this.argv.remote;
        return cb(remote);
      }
    };

    GitPush.prototype.getBranch = function(cb) {
      var branch, currentBranch;
      currentBranch = "master";
      if (this.argv.m || this.argv.master) {
        return cb("master");
      }
      if (this.argv.d || this.argv.dev) {
        return cb("dev");
      }
      if (!(this.argv.b || this.argv.branch)) {
        return exec("git branch", (function(_this) {
          return function(err, branches) {
            var b;
            b = branches.trim('\n').split('\n').map(function(b) {
              if (b[0] === "*") {
                currentBranch = b.slice(2);
                return currentBranch.trim();
              } else {
                return b.trim();
              }
            });
            if (_this.argv.c || _this.argv["current-branch"]) {
              return cb(currentBranch);
            }
            if (indexOf.call(b, "master") < 0) {
              b = ["master"].concat(b);
            }
            return inquirer.prompt([
              {
                name: "branch",
                message: "---> branch?",
                type: "list",
                choices: b,
                "default": currentBranch
              }, {
                name: "pushto",
                message: "---> to which remote branch?",
                type: "list",
                choices: b,
                "default": currentBranch
              }
            ], function(answers) {
              return cb(answers.branch, answers.pushto);
            });
          };
        })(this));
      } else {
        branch = this.argv.b || this.argv.branch;
        return cb(branch);
      }
    };

    GitPush.prototype.help = function() {
      return "Usage: ph [options]\n\n" + (chalk.bold(chalk.yellow("== Action =="))) + "\nBy default, do a git push.\nHowever, by specifing " + (chalk.green("--pull")) + " or " + (chalk.green("-l")) + "\nthis behavior can be switched, so a pull will occur instead.\n\n" + (chalk.bold(chalk.yellow("== Branch Choices =="))) + "\n" + (chalk.cyan("-m")) + " branch = master\n" + (chalk.cyan("-d")) + " branch = dev\n" + (chalk.cyan("-c")) + " branch = currently active branch\n\n" + (chalk.bold(chalk.yellow("== Remote Choices =="))) + "\n" + (chalk.magenta("-o")) + " remote = origin\n" + (chalk.magenta("-h")) + " remote = heroku\n" + (chalk.magenta("-p")) + " remote = production\n" + (chalk.magenta("-u")) + " remote = upstream\n\nAny other arguments are just passed through to git push/pull.\n\n== Examples ==\n" + (chalk.blue("ph c")) + " or " + (chalk.blue("ph --current-branch")) + "\n- ask for the remote but push to the current branch.\n\n" + (chalk.blue("ph oc")) + " or " + (chalk.blue("ph --remote origin --current-branch")) + "\n- push to origin the current branch.\n\n" + (chalk.blue("ph hm")) + " or " + (chalk.blue("ph -h -m")) + " or " + (chalk.blue("ph --remote heroku --branch master")) + "\n- push to heroku the master branch.\n\n" + (chalk.blue("ph oml")) + " or " + (chalk.blue("ph --pull --branch master --remote origin")) + "\n- pull from master the current branch.";
    };

    return GitPush;

  })();

  exports.GitPush = GitPush;

  exists("./.git", function(doesit) {
    if (doesit || argv.help || argv['?']) {
      return new GitPush(argv);
    } else {
      return console.log(chalk.red("This isn't a git repo!"));
    }
  });

}).call(this);
